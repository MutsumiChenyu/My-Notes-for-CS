
## Zero-Copy Philosophy


### 中心扩散算法

![[中心扩散算法.jpg|500]]

#### 我的代码 纯垃圾 $$O(N^3)$$
暴力解法 三次循环+一堆补丁

 ```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        abc = ''
        maxlength = 0
        if n == 1:
            return s
        elif n == 2 and s[0] == s[1]:
            return s
        elif n == 3 and s[0] == s[2]:
            return s
        elif n == 3 and s[1] == s[2]:
            return s[1:3]
        elif n == 3 and s[0] == s[1]:
            return s[0:2]
        for i in range(n):
            for r in range(n - i):
                temp = s[i : i + r + 1]
                is_palindrome = True
                for p in range(r + 1):
                    if s[i + r - p] != s[i + p]:
                        is_palindrome = False
                        break
                if is_palindrome:
                    if len(temp) > maxlength:
                        maxlength = len(temp)
                        abc = temp
        return abc
 ```




#### 正解 $$O(N^2)$$
思路是确定一个中心字母 然后往外一步步扩散 注意 一次往左一次往右交替
```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        # 如果是空的或者只有1个字，直接返回
        if len(s) < 2: return s
        
        # 定义一个 helper 函数：负责从中心向两边扩散
        def expand(left, right):
            # 当 左没有越界，右没有越界，且两边的字相等时
            while left >= 0 and right < len(s) and s[left] == s[right]:
                left -= 1  # 左边往左走
                right += 1 # 右边往右走
            # 循环结束时，s[left] != s[right] 了，所以回文是 (left+1) 到 (right-1)
            # 切片写法是 [left+1 : right]
            return s[left + 1 : right]

        result = ""
        
        for i in range(len(s)):
            # 情况1：奇数长度，中心是一个字 (比如 "aba"，中心是 i)
            s1 = expand(i, i)
            if len(s1) > len(result): result = s1
            
            # 情况2：偶数长度，中心是两个字 (比如 "abba"，中心是 i 和 i+1)
            s2 = expand(i, i + 1)
            if len(s2) > len(result): result = s2
            
        return result
```