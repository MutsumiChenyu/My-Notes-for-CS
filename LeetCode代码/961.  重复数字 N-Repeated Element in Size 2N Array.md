
#### 我的代码

乱糟糟的 双指针法

```python
class Solution:
    def repeatedNTimes(self, nums: List[int]) -> int:
        n = 0.5*(len(nums))
        N = int(2*n)
        nums.sort()
        left, right = 0, 1
        for i in range(N):
            if nums[left] == nums[right] and right < N - 1:
                if right - left + 1 == 2 and N == 4:
                    return nums[left]
                right += 1
            elif nums[left] == nums[right] and right == N - 1:
                return nums[right]
            elif nums[left] != nums[right]:
                templ, tempr = left, right
                left, right = right, right + 1

                if tempr - templ != 1:
                    length = tempr - templ
                elif tempr - templ == 1 and nums[tempr] != nums[templ]:
                    length = 0
                elif tempr - templ == 1 and nums[tempr] == nums[templ]:
                    length = 2

                if length == n:
                    return nums[templ
```

#### 双指针优化版

```python
class Solution:
    def repeatedNTimes(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums) // 2
        
        left = 0
        while left < len(nums):
            right = left
            # 扩展right直到遇到不同元素
            while right < len(nums) and nums[right] == nums[left]:
                right += 1
            
            # 统计当前元素出现次数
            count = right - left
            if count == n:
                return nums[left]
            
            # 跳到下一个不同元素
            left = right
        
        return -1
```

#### 正确解法 抽屉原理

```python
class Solution: 
def repeatedNTimes(self, a: List[int]) -> int: 

	d={} 
	
	for i in a: 
		if i in d: 
			return i 
		d[i]=1
```
